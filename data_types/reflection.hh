#pragma once

#include "simple_struct.hh"

#include <type_traits>

// This is manually-crafted reflection info for types in this librarty.
// This is what I woukld LOVE to have generated by the compiler

namespace reflection
{

//////////////////////////////
// common declarations

// Meta-object type, generated for each class/structure
template<typename T>
struct meta_object;

// Meta-enum type, generated for each enum
template<typename T>
struct meta_enum;

// Meta field-type, generated for each field.
// The type definition is an impelmentation detail, available via meta_object.
// Ordinal is used only to make the type unique. Field name would be better, but using const char* as template
// params is bit unwieldy in C++
template<typename Class, typename type, int Ordinal>
struct _meta_field;

#define META_FIELD(Class, Type, Name, Ordinal) \
template<>\
struct _meta_field<Class, Type, Ordinal>\
{\
	using class_type = Class;\
	using type = Type;\
\
	static constexpr const char* name = #Name;\
\
	static void set(class_type& instance, const type& value) { instance.Name = value; }\
	static const type& get(const class_type& instance) { return instance.Name; }\
};



// Mata-method type, generated for each method.
// The type is private, implementation-specific
template<typename Class, int Ordinal>
struct _meta_method;



////////////////////////////////
// record1

template<>
struct meta_object<::record1>
{
	using type = ::record1;

	static constexpr const char* name = "record1";
	static constexpr const char* qualified_name = "::record1";

	struct field_types
	{
		using number = _meta_field<::record1, int, 0>;
		using angle = _meta_field<::record1, double, 1>;
		using name = _meta_field<::record1, std::string, 2>;
	};

	template<typename Receiver>
	static void enumerate_fields(Receiver&& r)
	{
		r.template field<field_types::number>();
		r.template field<field_types::angle>();
		r.template field<field_types::name>();
	}
};


META_FIELD(::record1, int, number, 0)
META_FIELD(::record1, double, angle, 1)
META_FIELD(::record1, std::string, name, 2)


////////////////////////////////////
// some_enum


template<>
struct meta_enum<::some_enum>
{
	using type = ::some_enum;
	using underlying_type = std::underlying_type<type>::type;

	static constexpr const char* name = "some_enum";
	static constexpr const char* qualified_name = "::some_enum";

	static constexpr underlying_type min = 0;
	static constexpr underlying_type max = 7;

	template<typename Receiver>
	static void	enumerate_values(Receiver&& r)
	{
		r.value("Alpha", ::Alpha);
		r.value("Beta", ::Beta);
		r.value("Gamma", ::Gamma);
	}
};

///////////////////////////////////
// record2

template<>
struct meta_object<::record2>
{
	using type = ::record2;

	static constexpr const char* name = "record2";
	static constexpr const char* qualified_name = "::record2";

	struct field_types
	{
		using size = _meta_field<::record2, std::int64_t, 0>;
		using location = _meta_field<::record2, std::string, 1>;
		using type = _meta_field<::record2, ::some_enum, 2>;
	};

	template<typename Receiver>
	static void enumerate_fields(Receiver&& r)
	{
		r.template field<field_types::size>();
		r.template field<field_types::location>();
		r.template field<field_types::type>();
	}
};

META_FIELD(::record2, std::int64_t, size, 0)
META_FIELD(::record2, std::string, location, 1)
META_FIELD(::record2, ::some_enum, type, 2)


} // ns
