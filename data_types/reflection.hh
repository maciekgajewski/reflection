#pragma once

#include "simple_struct.hh"
#include "simple_class.hh"

#include <type_traits>
#include <tuple>

// This is manually-crafted reflection info for types in this librarty.
// This is what I woukld LOVE to have generated by the compiler

namespace reflection
{

//////////////////////////////
// common declarations

// Meta-object type, generated for each class/structure
template<typename T>
struct meta_object;

// Meta-enum type, generated for each enum
template<typename T>
struct meta_enum;

// Meta field-type, generated for each field.
// The type definition is an impelmentation detail, available via meta_object.
// Ordinal is used only to make the type unique. Field name would be better, but using const char* as template
// params is bit unwieldy in C++
template<typename Class, int Ordinal>
struct _meta_field;

template<typename Class, int Ordinal>
struct _meta_method;

#define META_FIELD(Class, Type, Name, Ordinal) \
template<>\
struct _meta_field<Class, Ordinal>\
{\
	using class_type = Class;\
	using type = Type;\
\
	static constexpr const char* name = #Name;\
\
	static void set(class_type& instance, const type& value) { instance.Name = value; }\
	static const type& get(const class_type& instance) { return instance.Name; }\
};



// Mata-method type, generated for each method.
// The type is private, implementation-specific
template<typename Class, int Ordinal>
struct _meta_method;

// namespaces
struct root_namespace;

struct _namespace_ProjectNamespace;


////////////////////////////////
// record1

template<>
struct meta_object<::record1>
{
	using type = ::record1;
	using parent_namespace = root_namespace;

	static constexpr const char* name = "record1";

	struct field_types
	{
		using number = _meta_field<::record1, 0>;
		using angle = _meta_field<::record1, 1>;
		using name = _meta_field<::record1, 2>;
	};

	template<typename Receiver>
	static void enumerate_fields(Receiver&& r)
	{
		r.template field<field_types::number>();
		r.template field<field_types::angle>();
		r.template field<field_types::name>();
	}
};


META_FIELD(::record1, int, number, 0)
META_FIELD(::record1, double, angle, 1)
META_FIELD(::record1, std::string, name, 2)


////////////////////////////////////
// some_enum


template<>
struct meta_enum<::some_enum>
{
	using type = ::some_enum;
	using underlying_type = std::underlying_type<type>::type;
	using parent_namespace = root_namespace;

	static constexpr const char* name = "some_enum";

	static constexpr underlying_type min = 0;
	static constexpr underlying_type max = 7;

	template<typename Receiver>
	static void	enumerate_values(Receiver&& r)
	{
		r.value("Alpha", ::Alpha);
		r.value("Beta", ::Beta);
		r.value("Gamma", ::Gamma);
	}
};

///////////////////////////////////
// record2

template<>
struct meta_object<::record2>
{
	using type = ::record2;
	using parent_namespace = root_namespace;

	static constexpr const char* name = "record2";

	struct field_types
	{
		using size = _meta_field<::record2, 0>;
		using location = _meta_field<::record2, 1>;
		using type = _meta_field<::record2, 2>;
	};

	template<typename Receiver>
	static void enumerate_fields(Receiver&& r)
	{
		r.template field<field_types::size>();
		r.template field<field_types::location>();
		r.template field<field_types::type>();
	}
};

META_FIELD(::record2, std::int64_t, size, 0)
META_FIELD(::record2, std::string, location, 1)
META_FIELD(::record2, ::some_enum, type, 2)


//////////////////////////////////////////////
// Simple class

template<>
struct meta_object<::ProjectNamespace::SimpleClass>
{
	using type = ::ProjectNamespace::SimpleClass;
	using parent_namespace = _namespace_ProjectNamespace;

	static constexpr const char* name = "SimpleClass";

	struct method_types
	{
		using AddToCounter = _meta_method<::ProjectNamespace::SimpleClass, 0>;
		using SetName = _meta_method<::ProjectNamespace::SimpleClass, 1>;
		using GetCounter = _meta_method<::ProjectNamespace::SimpleClass, 2>;
		using GetName = _meta_method<::ProjectNamespace::SimpleClass, 3>;
	};

	template<typename Receiver>
	static void enumerate_methods(Receiver&& r)
	{
		r.template method<method_types::AddToCounter>();
		r.template method<method_types::SetName>();
		r.template method<method_types::GetCounter>();
		r.template method<method_types::GetName>();
	}
};

template<>
struct _meta_method<::ProjectNamespace::SimpleClass, 0>
{
	using class_type = ::ProjectNamespace::SimpleClass;

	static constexpr const char* name = "AddToCounter";

	using signature = void(unsigned);

	static void call(class_type& _instance, unsigned value)
	{
		_instance.AddToCounter(value);
	}

	template<typename TupleType>
	static void unpack(class_type& _instance, TupleType&& params)
	{
		_instance.AddToCounter(std::get<0>(params));
	}

	template<typename Receiver>
	static void enumerate_params(Receiver&& r)
	{
		r.template param<unsigned>("value");
	}
};

template<>
struct _meta_method<::ProjectNamespace::SimpleClass, 1>
{
	using class_type = ::ProjectNamespace::SimpleClass;

	static constexpr const char* name = "SetName";

	using signature = void(const std::string&, int);

	static void call(class_type& _instance, const std::string& name, int number)
	{
		_instance.SetName(name, number);
	}

	template<typename TupleType>
	static void unpack(class_type& _instance, TupleType&& params)
	{
		_instance.SetName(std::get<0>(params), std::get<1>(params));
	}

	template<typename Receiver>
	static void enumerate_params(Receiver&& r)
	{
		r.template param<const std::string&>("name");
		r.template param<int>("number");
	}
};

template<>
struct _meta_method<::ProjectNamespace::SimpleClass, 2>
{
	using class_type = ::ProjectNamespace::SimpleClass;

	static constexpr const char* name = "GetCounter";

	using signature = unsigned();

	static unsigned call(class_type& _instance)
	{
		return _instance.GetCounter();
	}

	template<typename TupleType>
	static unsigned unpack(class_type& _instance, TupleType&& params)
	{
		return _instance.GetCounter();
	}

	template<typename Receiver>
	static void enumerate_params(Receiver&& r)
	{
	}
};

template<>
struct _meta_method<::ProjectNamespace::SimpleClass, 3>
{
	using class_type = ::ProjectNamespace::SimpleClass;

	static constexpr const char* name = "GetName";

	using signature = std::string();

	static std::string call(class_type& _instance)
	{
		return _instance.GetName();
	}

	template<typename TupleType>
	static std::string unpack(class_type& _instance, TupleType&& params)
	{
		return _instance.GetName();
	}

	template<typename Receiver>
	static void enumerate_params(Receiver&& r)
	{
	}
};

struct	_namespace_ProjectNamespace
{
	using parent_namespace = root_namespace;
	static constexpr const char* name = "ProjectNamespace";

	template<typename Receiver>
	static void enumerate_classes(Receiver&& r)
	{
		r.template class_<ProjectNamespace::SimpleClass>();
	}

	template<typename Receiver>
	static void enumerate_enums(Receiver&& r)
	{
	}

	template<typename Receiver>
	static void enumerate_namespaces(Receiver&& r)
	{
	}
};

struct root_namespace
{
	template<typename Receiver>
	static void enumerate_classes(Receiver&& r)
	{
		r.template class_<::record1>();
		r.template class_<::record2>();
	}

	template<typename Receiver>
	static void enumerate_enums(Receiver&& r)
	{
		r.template enum_<::some_enum>();
	}

	template<typename Receiver>
	static void enumerate_namespaces(Receiver&& r)
	{
	};
};

} // ns
