#pragma once

#include "simple_struct.hh"
#include "simple_class.hh"

#include <type_traits>

// This is manually-crafted reflection info for types in this librarty.
// This is what I woukld LOVE to have generated by the compiler

namespace reflection
{

//////////////////////////////
// common declarations

// Meta-object type, generated for each class/structure
template<typename T>
struct meta_object;

// Meta-enum type, generated for each enum
template<typename T>
struct meta_enum;

// Meta field-type, generated for each field.
// The type definition is an impelmentation detail, available via meta_object.
// Ordinal is used only to make the type unique. Field name would be better, but using const char* as template
// params is bit unwieldy in C++
template<typename Class, int Ordinal>
struct _meta_field;

template<typename Class, int Ordinal>
struct _meta_method;

#define META_FIELD(Class, Type, Name, Ordinal) \
template<>\
struct _meta_field<Class, Ordinal>\
{\
	using class_type = Class;\
	using type = Type;\
\
	static constexpr const char* name = #Name;\
\
	static void set(class_type& instance, const type& value) { instance.Name = value; }\
	static const type& get(const class_type& instance) { return instance.Name; }\
};



// Mata-method type, generated for each method.
// The type is private, implementation-specific
template<typename Class, int Ordinal>
struct _meta_method;



////////////////////////////////
// record1

template<>
struct meta_object<::record1>
{
	using type = ::record1;

	static constexpr const char* name = "record1";
	static constexpr const char* qualified_name = "::record1";

	struct field_types
	{
		using number = _meta_field<::record1, 0>;
		using angle = _meta_field<::record1, 1>;
		using name = _meta_field<::record1, 2>;
	};

	template<typename Receiver>
	static void enumerate_fields(Receiver&& r)
	{
		r.template field<field_types::number>();
		r.template field<field_types::angle>();
		r.template field<field_types::name>();
	}
};


META_FIELD(::record1, int, number, 0)
META_FIELD(::record1, double, angle, 1)
META_FIELD(::record1, std::string, name, 2)


////////////////////////////////////
// some_enum


template<>
struct meta_enum<::some_enum>
{
	using type = ::some_enum;
	using underlying_type = std::underlying_type<type>::type;

	static constexpr const char* name = "some_enum";
	static constexpr const char* qualified_name = "::some_enum";

	static constexpr underlying_type min = 0;
	static constexpr underlying_type max = 7;

	template<typename Receiver>
	static void	enumerate_values(Receiver&& r)
	{
		r.value("Alpha", ::Alpha);
		r.value("Beta", ::Beta);
		r.value("Gamma", ::Gamma);
	}
};

///////////////////////////////////
// record2

template<>
struct meta_object<::record2>
{
	using type = ::record2;

	static constexpr const char* name = "record2";
	static constexpr const char* qualified_name = "::record2";

	struct field_types
	{
		using size = _meta_field<::record2, 0>;
		using location = _meta_field<::record2, 1>;
		using type = _meta_field<::record2, 2>;
	};

	template<typename Receiver>
	static void enumerate_fields(Receiver&& r)
	{
		r.template field<field_types::size>();
		r.template field<field_types::location>();
		r.template field<field_types::type>();
	}
};

META_FIELD(::record2, std::int64_t, size, 0)
META_FIELD(::record2, std::string, location, 1)
META_FIELD(::record2, ::some_enum, type, 2)


//////////////////////////////////////////////
// Simple class

template<>
struct meta_object<::ProjectNamespace::SimpleClass>
{
	using type = ::ProjectNamespace::SimpleClass;

	static constexpr const char* name = "SimpleClass";
	static constexpr const char* qualified_name = "::ProjectNamespace::SimpleClass";

	struct method_types
	{
		using AddToCounter = _meta_method<::ProjectNamespace::SimpleClass, 0>;
		using GetCounter = _meta_method<::ProjectNamespace::SimpleClass, 1>;
	};

	template<typename Receiver>
	static void enumerate_methods(Receiver&& r)
	{
		r.template method<method_types::AddToCounter>();
		r.template method<method_types::GetCounter>();
	}
};

template<>
struct _meta_method<::ProjectNamespace::SimpleClass, 0>
{
	using class_type = ::ProjectNamespace::SimpleClass;

	static constexpr const char* name = "AddToCounter";

	using signature = void(unsigned);

	static void call(class_type& _instance, unsigned value)
	{
		_instance.AddToCounter(value);
	}
};

template<>
struct _meta_method<::ProjectNamespace::SimpleClass, 1>
{
	using class_type = ::ProjectNamespace::SimpleClass;

	static constexpr const char* name = "GetCounter";

	using signature = unsigned();

	static unsigned call(class_type& _instance)
	{
		return _instance.GetCounter();
	}
};


} // ns
